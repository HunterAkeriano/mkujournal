/* tslint:disable */
/* eslint-disable */
/**
 * Vitamin API
 * Документация API для Vitamin Online
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AuthLoginPost200Response
 */
export interface AuthLoginPost200Response {
    /**
     * 
     * @type {string}
     * @memberof AuthLoginPost200Response
     */
    'accessToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthLoginPost200Response
     */
    'refreshToken'?: string;
}
/**
 * 
 * @export
 * @interface AuthLoginPostRequest
 */
export interface AuthLoginPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthLoginPostRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AuthLoginPostRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AuthRefreshTokenPostRequest
 */
export interface AuthRefreshTokenPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthRefreshTokenPostRequest
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface AuthRegisterPost201Response
 */
export interface AuthRegisterPost201Response {
    /**
     * 
     * @type {string}
     * @memberof AuthRegisterPost201Response
     */
    'message'?: string;
    /**
     * 
     * @type {AuthRegisterPost201ResponseUser}
     * @memberof AuthRegisterPost201Response
     */
    'user'?: AuthRegisterPost201ResponseUser;
}
/**
 * 
 * @export
 * @interface AuthRegisterPost201ResponseUser
 */
export interface AuthRegisterPost201ResponseUser {
    /**
     * 
     * @type {string}
     * @memberof AuthRegisterPost201ResponseUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthRegisterPost201ResponseUser
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthRegisterPost201ResponseUser
     */
    'refreshToken'?: string;
}
/**
 * 
 * @export
 * @interface AuthRegisterPostRequest
 */
export interface AuthRegisterPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthRegisterPostRequest
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthRegisterPostRequest
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthRegisterPostRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AuthRegisterPostRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof AuthRegisterPostRequest
     */
    'role_type': AuthRegisterPostRequestRoleTypeEnum;
}

export const AuthRegisterPostRequestRoleTypeEnum = {
    Regular: 'regular',
    Whosale: 'whosale'
} as const;

export type AuthRegisterPostRequestRoleTypeEnum = typeof AuthRegisterPostRequestRoleTypeEnum[keyof typeof AuthRegisterPostRequestRoleTypeEnum];

/**
 * 
 * @export
 * @interface AuthResetPasswordPostRequest
 */
export interface AuthResetPasswordPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthResetPasswordPostRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface AuthSetNewPasswordPostRequest
 */
export interface AuthSetNewPasswordPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthSetNewPasswordPostRequest
     */
    'resetToken': string;
    /**
     * 
     * @type {string}
     * @memberof AuthSetNewPasswordPostRequest
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface CatalogAllListGet200Response
 */
export interface CatalogAllListGet200Response {
    /**
     * 
     * @type {Array<CatalogAllListGet200ResponseDataInner>}
     * @memberof CatalogAllListGet200Response
     */
    'data'?: Array<CatalogAllListGet200ResponseDataInner>;
    /**
     * 
     * @type {CatalogAllListGet200ResponseMeta}
     * @memberof CatalogAllListGet200Response
     */
    'meta'?: CatalogAllListGet200ResponseMeta;
}
/**
 * Объект товара каталога
 * @export
 * @interface CatalogAllListGet200ResponseDataInner
 */
export interface CatalogAllListGet200ResponseDataInner {
    /**
     * 
     * @type {number}
     * @memberof CatalogAllListGet200ResponseDataInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CatalogAllListGet200ResponseDataInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogAllListGet200ResponseDataInner
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface CatalogAllListGet200ResponseMeta
 */
export interface CatalogAllListGet200ResponseMeta {
    /**
     * 
     * @type {number}
     * @memberof CatalogAllListGet200ResponseMeta
     */
    'totalItems'?: number;
    /**
     * 
     * @type {number}
     * @memberof CatalogAllListGet200ResponseMeta
     */
    'currentPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof CatalogAllListGet200ResponseMeta
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface CatalogCreateOrderPost200Response
 */
export interface CatalogCreateOrderPost200Response {
    /**
     * 
     * @type {string}
     * @memberof CatalogCreateOrderPost200Response
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface CatalogCreateOrderPost400Response
 */
export interface CatalogCreateOrderPost400Response {
    /**
     * 
     * @type {string}
     * @memberof CatalogCreateOrderPost400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface CatalogCreateOrderPost404Response
 */
export interface CatalogCreateOrderPost404Response {
    /**
     * 
     * @type {string}
     * @memberof CatalogCreateOrderPost404Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface CatalogCreateOrderPost500Response
 */
export interface CatalogCreateOrderPost500Response {
    /**
     * 
     * @type {string}
     * @memberof CatalogCreateOrderPost500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface CatalogCreateOrderPostRequest
 */
export interface CatalogCreateOrderPostRequest {
    /**
     * Массив объектов заказа. Каждый объект должен содержать поля product_id и quantity.
     * @type {Array<CatalogCreateOrderPostRequestOrderInner>}
     * @memberof CatalogCreateOrderPostRequest
     */
    'order': Array<CatalogCreateOrderPostRequestOrderInner>;
    /**
     * Идентификатор пользователя. Если не передан, заказ не сохраняется в профиль.
     * @type {string}
     * @memberof CatalogCreateOrderPostRequest
     */
    'user_id'?: string;
}
/**
 * 
 * @export
 * @interface CatalogCreateOrderPostRequestOrderInner
 */
export interface CatalogCreateOrderPostRequestOrderInner {
    /**
     * 
     * @type {number}
     * @memberof CatalogCreateOrderPostRequestOrderInner
     */
    'product_id': number;
    /**
     * 
     * @type {number}
     * @memberof CatalogCreateOrderPostRequestOrderInner
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface CatalogRecommendationsGet200Response
 */
export interface CatalogRecommendationsGet200Response {
    /**
     * Массив рекомендованных товаров
     * @type {Array<CatalogRecommendationsGet200ResponseDataInner>}
     * @memberof CatalogRecommendationsGet200Response
     */
    'data'?: Array<CatalogRecommendationsGet200ResponseDataInner>;
}
/**
 * 
 * @export
 * @interface CatalogRecommendationsGet200ResponseDataInner
 */
export interface CatalogRecommendationsGet200ResponseDataInner {
    /**
     * 
     * @type {number}
     * @memberof CatalogRecommendationsGet200ResponseDataInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CatalogRecommendationsGet200ResponseDataInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogRecommendationsGet200ResponseDataInner
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface CatalogRecommendationsGet500Response
 */
export interface CatalogRecommendationsGet500Response {
    /**
     * 
     * @type {string}
     * @memberof CatalogRecommendationsGet500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ProfileChangePasswordPut200Response
 */
export interface ProfileChangePasswordPut200Response {
    /**
     * 
     * @type {string}
     * @memberof ProfileChangePasswordPut200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ProfileChangePasswordPut400Response
 */
export interface ProfileChangePasswordPut400Response {
    /**
     * 
     * @type {string}
     * @memberof ProfileChangePasswordPut400Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ProfileChangePasswordPut404Response
 */
export interface ProfileChangePasswordPut404Response {
    /**
     * 
     * @type {string}
     * @memberof ProfileChangePasswordPut404Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ProfileChangePasswordPut500Response
 */
export interface ProfileChangePasswordPut500Response {
    /**
     * 
     * @type {string}
     * @memberof ProfileChangePasswordPut500Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileChangePasswordPut500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ProfileChangePasswordPutRequest
 */
export interface ProfileChangePasswordPutRequest {
    /**
     * Старый пароль пользователя
     * @type {string}
     * @memberof ProfileChangePasswordPutRequest
     */
    'old_password': string;
    /**
     * Новый пароль пользователя
     * @type {string}
     * @memberof ProfileChangePasswordPutRequest
     */
    'new_password': string;
}
/**
 * 
 * @export
 * @interface ProfileInfoGet200Response
 */
export interface ProfileInfoGet200Response {
    /**
     * 
     * @type {number}
     * @memberof ProfileInfoGet200Response
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProfileInfoGet200Response
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileInfoGet200Response
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ProfileInfoGet400Response
 */
export interface ProfileInfoGet400Response {
    /**
     * 
     * @type {string}
     * @memberof ProfileInfoGet400Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileInfoGet400Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ProfileOrderHistoryGet200Response
 */
export interface ProfileOrderHistoryGet200Response {
    /**
     * Список заказов
     * @type {Array<ProfileOrderHistoryGet200ResponseOrdersInner>}
     * @memberof ProfileOrderHistoryGet200Response
     */
    'orders'?: Array<ProfileOrderHistoryGet200ResponseOrdersInner>;
}
/**
 * 
 * @export
 * @interface ProfileOrderHistoryGet200ResponseOrdersInner
 */
export interface ProfileOrderHistoryGet200ResponseOrdersInner {
    /**
     * Дата создания заказа
     * @type {string}
     * @memberof ProfileOrderHistoryGet200ResponseOrdersInner
     */
    'date_created'?: string;
    /**
     * Номер заказа
     * @type {string}
     * @memberof ProfileOrderHistoryGet200ResponseOrdersInner
     */
    'order_number'?: string;
    /**
     * Список товаров в заказе
     * @type {Array<ProfileOrderHistoryGet200ResponseOrdersInnerItemsInner>}
     * @memberof ProfileOrderHistoryGet200ResponseOrdersInner
     */
    'items'?: Array<ProfileOrderHistoryGet200ResponseOrdersInnerItemsInner>;
}
/**
 * 
 * @export
 * @interface ProfileOrderHistoryGet200ResponseOrdersInnerItemsInner
 */
export interface ProfileOrderHistoryGet200ResponseOrdersInnerItemsInner {
    /**
     * Информация о товаре
     * @type {{ [key: string]: any; }}
     * @memberof ProfileOrderHistoryGet200ResponseOrdersInnerItemsInner
     */
    'product'?: { [key: string]: any; };
    /**
     * Количество товара
     * @type {number}
     * @memberof ProfileOrderHistoryGet200ResponseOrdersInnerItemsInner
     */
    'quantity'?: number;
    /**
     * Признак наличия скидки
     * @type {boolean}
     * @memberof ProfileOrderHistoryGet200ResponseOrdersInnerItemsInner
     */
    'is_discount'?: boolean;
    /**
     * Итоговая сумма с учетом скидки
     * @type {number}
     * @memberof ProfileOrderHistoryGet200ResponseOrdersInnerItemsInner
     */
    'total_sum'?: number;
}
/**
 * 
 * @export
 * @interface ProfileOrderHistoryGet404Response
 */
export interface ProfileOrderHistoryGet404Response {
    /**
     * 
     * @type {string}
     * @memberof ProfileOrderHistoryGet404Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ProfileOrderHistoryGet500Response
 */
export interface ProfileOrderHistoryGet500Response {
    /**
     * 
     * @type {string}
     * @memberof ProfileOrderHistoryGet500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ProfileUpdateCardInfoPut200Response
 */
export interface ProfileUpdateCardInfoPut200Response {
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdateCardInfoPut200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ProfileUpdateCardInfoPut400Response
 */
export interface ProfileUpdateCardInfoPut400Response {
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdateCardInfoPut400Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdateCardInfoPut400Response
     */
    'field'?: string;
}
/**
 * 
 * @export
 * @interface ProfileUpdateCardInfoPut500Response
 */
export interface ProfileUpdateCardInfoPut500Response {
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdateCardInfoPut500Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdateCardInfoPut500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ProfileUpdateCardInfoPutRequest
 */
export interface ProfileUpdateCardInfoPutRequest {
    /**
     * Номер банковской карты
     * @type {string}
     * @memberof ProfileUpdateCardInfoPutRequest
     */
    'card_number': string;
    /**
     * CVV-код карты
     * @type {string}
     * @memberof ProfileUpdateCardInfoPutRequest
     */
    'card_cvv': string;
    /**
     * Дата истечения срока действия карты (формат MM/YY или MM/YYYY)
     * @type {string}
     * @memberof ProfileUpdateCardInfoPutRequest
     */
    'card_date': string;
}
/**
 * 
 * @export
 * @interface ProfileUpdateProfilePut200Response
 */
export interface ProfileUpdateProfilePut200Response {
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdateProfilePut200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ProfileUpdateProfilePut400Response
 */
export interface ProfileUpdateProfilePut400Response {
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdateProfilePut400Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdateProfilePut400Response
     */
    'field'?: string;
}
/**
 * 
 * @export
 * @interface ProfileUpdateProfilePut404Response
 */
export interface ProfileUpdateProfilePut404Response {
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdateProfilePut404Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ProfileUpdateProfilePut500Response
 */
export interface ProfileUpdateProfilePut500Response {
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdateProfilePut500Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdateProfilePut500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ProfileUpdateProfilePutRequest
 */
export interface ProfileUpdateProfilePutRequest {
    /**
     * Адрес электронной почты
     * @type {string}
     * @memberof ProfileUpdateProfilePutRequest
     */
    'email': string;
    /**
     * Имя пользователя
     * @type {string}
     * @memberof ProfileUpdateProfilePutRequest
     */
    'first_name': string;
    /**
     * Фамилия пользователя
     * @type {string}
     * @memberof ProfileUpdateProfilePutRequest
     */
    'last_name': string;
    /**
     * Первый адрес
     * @type {string}
     * @memberof ProfileUpdateProfilePutRequest
     */
    'address_one': string;
    /**
     * Второй адрес
     * @type {string}
     * @memberof ProfileUpdateProfilePutRequest
     */
    'address_two': string;
    /**
     * Город
     * @type {string}
     * @memberof ProfileUpdateProfilePutRequest
     */
    'city': string;
    /**
     * Телефон (должен быть валидным)
     * @type {string}
     * @memberof ProfileUpdateProfilePutRequest
     */
    'phone': string;
    /**
     * Почтовый индекс
     * @type {string}
     * @memberof ProfileUpdateProfilePutRequest
     */
    'postal_code': string;
    /**
     * Область или провинция
     * @type {string}
     * @memberof ProfileUpdateProfilePutRequest
     */
    'state_province': string;
}
/**
 * 
 * @export
 * @interface ProfileUsersGet200Response
 */
export interface ProfileUsersGet200Response {
    /**
     * Список пользователей
     * @type {Array<ProfileUsersGet200ResponseDataInner>}
     * @memberof ProfileUsersGet200Response
     */
    'data'?: Array<ProfileUsersGet200ResponseDataInner>;
    /**
     * 
     * @type {ProfileUsersGet200ResponseMeta}
     * @memberof ProfileUsersGet200Response
     */
    'meta'?: ProfileUsersGet200ResponseMeta;
}
/**
 * 
 * @export
 * @interface ProfileUsersGet200ResponseDataInner
 */
export interface ProfileUsersGet200ResponseDataInner {
    /**
     * Уникальный идентификатор пользователя (user_id)
     * @type {string}
     * @memberof ProfileUsersGet200ResponseDataInner
     */
    'id'?: string;
    /**
     * Email пользователя
     * @type {string}
     * @memberof ProfileUsersGet200ResponseDataInner
     */
    'email'?: string;
    /**
     * Роль пользователя
     * @type {string}
     * @memberof ProfileUsersGet200ResponseDataInner
     */
    'role'?: string;
    /**
     * Имя пользователя (из профиля)
     * @type {string}
     * @memberof ProfileUsersGet200ResponseDataInner
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ProfileUsersGet200ResponseMeta
 */
export interface ProfileUsersGet200ResponseMeta {
    /**
     * 
     * @type {number}
     * @memberof ProfileUsersGet200ResponseMeta
     */
    'totalItems'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProfileUsersGet200ResponseMeta
     */
    'currentPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProfileUsersGet200ResponseMeta
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface ProfileUsersGet400Response
 */
export interface ProfileUsersGet400Response {
    /**
     * 
     * @type {string}
     * @memberof ProfileUsersGet400Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ProfileUsersGet500Response
 */
export interface ProfileUsersGet500Response {
    /**
     * 
     * @type {string}
     * @memberof ProfileUsersGet500Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileUsersGet500Response
     */
    'error'?: string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Проверяет, действителен ли токен для сброса пароля
         * @summary Проверка действительности токена для сброса пароля
         * @param {string} token Токен сброса пароля
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCheckResetTokenGet: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('authCheckResetTokenGet', 'token', token)
            const localVarPath = `/auth/check-reset-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (token != null) {
                localVarHeaderParameter['token'] = String(token);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Позволяет пользователю войти в систему
         * @summary Авторизация пользователя
         * @param {AuthLoginPostRequest} authLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost: async (authLoginPostRequest: AuthLoginPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authLoginPostRequest' is not null or undefined
            assertParamExists('authLoginPost', 'authLoginPostRequest', authLoginPostRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authLoginPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновляет токены на основе предоставленного refresh токена
         * @summary Обновить access и refresh токены
         * @param {AuthRefreshTokenPostRequest} authRefreshTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshTokenPost: async (authRefreshTokenPostRequest: AuthRefreshTokenPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authRefreshTokenPostRequest' is not null or undefined
            assertParamExists('authRefreshTokenPost', 'authRefreshTokenPostRequest', authRefreshTokenPostRequest)
            const localVarPath = `/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRefreshTokenPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создает нового пользователя в системе
         * @summary Регистрация нового пользователя
         * @param {AuthRegisterPostRequest} authRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterPost: async (authRegisterPostRequest: AuthRegisterPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authRegisterPostRequest' is not null or undefined
            assertParamExists('authRegisterPost', 'authRegisterPostRequest', authRegisterPostRequest)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRegisterPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отправляет новый пароль на указанный email
         * @summary Сброс пароля
         * @param {AuthResetPasswordPostRequest} authResetPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResetPasswordPost: async (authResetPasswordPostRequest: AuthResetPasswordPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authResetPasswordPostRequest' is not null or undefined
            assertParamExists('authResetPasswordPost', 'authResetPasswordPostRequest', authResetPasswordPostRequest)
            const localVarPath = `/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authResetPasswordPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Устанавливает новый пароль для пользователя по токену сброса пароля
         * @summary Установка нового пароля
         * @param {AuthSetNewPasswordPostRequest} authSetNewPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSetNewPasswordPost: async (authSetNewPasswordPostRequest: AuthSetNewPasswordPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authSetNewPasswordPostRequest' is not null or undefined
            assertParamExists('authSetNewPasswordPost', 'authSetNewPasswordPostRequest', authSetNewPasswordPostRequest)
            const localVarPath = `/auth/set-new-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authSetNewPasswordPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Проверяет, действителен ли токен для сброса пароля
         * @summary Проверка действительности токена для сброса пароля
         * @param {string} token Токен сброса пароля
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authCheckResetTokenGet(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authCheckResetTokenGet(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authCheckResetTokenGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Позволяет пользователю войти в систему
         * @summary Авторизация пользователя
         * @param {AuthLoginPostRequest} authLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginPost(authLoginPostRequest: AuthLoginPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthLoginPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginPost(authLoginPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Обновляет токены на основе предоставленного refresh токена
         * @summary Обновить access и refresh токены
         * @param {AuthRefreshTokenPostRequest} authRefreshTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRefreshTokenPost(authRefreshTokenPostRequest: AuthRefreshTokenPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthLoginPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRefreshTokenPost(authRefreshTokenPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authRefreshTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Создает нового пользователя в системе
         * @summary Регистрация нового пользователя
         * @param {AuthRegisterPostRequest} authRegisterPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRegisterPost(authRegisterPostRequest: AuthRegisterPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthRegisterPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRegisterPost(authRegisterPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Отправляет новый пароль на указанный email
         * @summary Сброс пароля
         * @param {AuthResetPasswordPostRequest} authResetPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authResetPasswordPost(authResetPasswordPostRequest: AuthResetPasswordPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authResetPasswordPost(authResetPasswordPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authResetPasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Устанавливает новый пароль для пользователя по токену сброса пароля
         * @summary Установка нового пароля
         * @param {AuthSetNewPasswordPostRequest} authSetNewPasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSetNewPasswordPost(authSetNewPasswordPostRequest: AuthSetNewPasswordPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSetNewPasswordPost(authSetNewPasswordPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authSetNewPasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Проверяет, действителен ли токен для сброса пароля
         * @summary Проверка действительности токена для сброса пароля
         * @param {AuthApiAuthCheckResetTokenGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCheckResetTokenGet(requestParameters: AuthApiAuthCheckResetTokenGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.authCheckResetTokenGet(requestParameters.token, options).then((request) => request(axios, basePath));
        },
        /**
         * Позволяет пользователю войти в систему
         * @summary Авторизация пользователя
         * @param {AuthApiAuthLoginPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost(requestParameters: AuthApiAuthLoginPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthLoginPost200Response> {
            return localVarFp.authLoginPost(requestParameters.authLoginPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновляет токены на основе предоставленного refresh токена
         * @summary Обновить access и refresh токены
         * @param {AuthApiAuthRefreshTokenPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshTokenPost(requestParameters: AuthApiAuthRefreshTokenPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthLoginPost200Response> {
            return localVarFp.authRefreshTokenPost(requestParameters.authRefreshTokenPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Создает нового пользователя в системе
         * @summary Регистрация нового пользователя
         * @param {AuthApiAuthRegisterPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterPost(requestParameters: AuthApiAuthRegisterPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthRegisterPost201Response> {
            return localVarFp.authRegisterPost(requestParameters.authRegisterPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Отправляет новый пароль на указанный email
         * @summary Сброс пароля
         * @param {AuthApiAuthResetPasswordPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResetPasswordPost(requestParameters: AuthApiAuthResetPasswordPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authResetPasswordPost(requestParameters.authResetPasswordPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Устанавливает новый пароль для пользователя по токену сброса пароля
         * @summary Установка нового пароля
         * @param {AuthApiAuthSetNewPasswordPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSetNewPasswordPost(requestParameters: AuthApiAuthSetNewPasswordPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authSetNewPasswordPost(requestParameters.authSetNewPasswordPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for authCheckResetTokenGet operation in AuthApi.
 * @export
 * @interface AuthApiAuthCheckResetTokenGetRequest
 */
export interface AuthApiAuthCheckResetTokenGetRequest {
    /**
     * Токен сброса пароля
     * @type {string}
     * @memberof AuthApiAuthCheckResetTokenGet
     */
    readonly token: string
}

/**
 * Request parameters for authLoginPost operation in AuthApi.
 * @export
 * @interface AuthApiAuthLoginPostRequest
 */
export interface AuthApiAuthLoginPostRequest {
    /**
     * 
     * @type {AuthLoginPostRequest}
     * @memberof AuthApiAuthLoginPost
     */
    readonly authLoginPostRequest: AuthLoginPostRequest
}

/**
 * Request parameters for authRefreshTokenPost operation in AuthApi.
 * @export
 * @interface AuthApiAuthRefreshTokenPostRequest
 */
export interface AuthApiAuthRefreshTokenPostRequest {
    /**
     * 
     * @type {AuthRefreshTokenPostRequest}
     * @memberof AuthApiAuthRefreshTokenPost
     */
    readonly authRefreshTokenPostRequest: AuthRefreshTokenPostRequest
}

/**
 * Request parameters for authRegisterPost operation in AuthApi.
 * @export
 * @interface AuthApiAuthRegisterPostRequest
 */
export interface AuthApiAuthRegisterPostRequest {
    /**
     * 
     * @type {AuthRegisterPostRequest}
     * @memberof AuthApiAuthRegisterPost
     */
    readonly authRegisterPostRequest: AuthRegisterPostRequest
}

/**
 * Request parameters for authResetPasswordPost operation in AuthApi.
 * @export
 * @interface AuthApiAuthResetPasswordPostRequest
 */
export interface AuthApiAuthResetPasswordPostRequest {
    /**
     * 
     * @type {AuthResetPasswordPostRequest}
     * @memberof AuthApiAuthResetPasswordPost
     */
    readonly authResetPasswordPostRequest: AuthResetPasswordPostRequest
}

/**
 * Request parameters for authSetNewPasswordPost operation in AuthApi.
 * @export
 * @interface AuthApiAuthSetNewPasswordPostRequest
 */
export interface AuthApiAuthSetNewPasswordPostRequest {
    /**
     * 
     * @type {AuthSetNewPasswordPostRequest}
     * @memberof AuthApiAuthSetNewPasswordPost
     */
    readonly authSetNewPasswordPostRequest: AuthSetNewPasswordPostRequest
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Проверяет, действителен ли токен для сброса пароля
     * @summary Проверка действительности токена для сброса пароля
     * @param {AuthApiAuthCheckResetTokenGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authCheckResetTokenGet(requestParameters: AuthApiAuthCheckResetTokenGetRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authCheckResetTokenGet(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Позволяет пользователю войти в систему
     * @summary Авторизация пользователя
     * @param {AuthApiAuthLoginPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLoginPost(requestParameters: AuthApiAuthLoginPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLoginPost(requestParameters.authLoginPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновляет токены на основе предоставленного refresh токена
     * @summary Обновить access и refresh токены
     * @param {AuthApiAuthRefreshTokenPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRefreshTokenPost(requestParameters: AuthApiAuthRefreshTokenPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRefreshTokenPost(requestParameters.authRefreshTokenPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Создает нового пользователя в системе
     * @summary Регистрация нового пользователя
     * @param {AuthApiAuthRegisterPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRegisterPost(requestParameters: AuthApiAuthRegisterPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRegisterPost(requestParameters.authRegisterPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Отправляет новый пароль на указанный email
     * @summary Сброс пароля
     * @param {AuthApiAuthResetPasswordPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authResetPasswordPost(requestParameters: AuthApiAuthResetPasswordPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authResetPasswordPost(requestParameters.authResetPasswordPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Устанавливает новый пароль для пользователя по токену сброса пароля
     * @summary Установка нового пароля
     * @param {AuthApiAuthSetNewPasswordPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authSetNewPasswordPost(requestParameters: AuthApiAuthSetNewPasswordPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authSetNewPasswordPost(requestParameters.authSetNewPasswordPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CatalogApi - axios parameter creator
 * @export
 */
export const CatalogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Возвращает список товаров с возможностью фильтрации по типу и поддержки пагинации.
         * @summary Получение списка товаров
         * @param {string} [type] Фильтр по типу товара (без учета регистра).
         * @param {number} [page] Номер страницы для пагинации.
         * @param {number} [limit] Количество элементов на странице.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogAllListGet: async (type?: string, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/catalog/all-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Принимает заказ в виде массива объектов, где каждый объект содержит идентификатор товара (`product_id`) и его количество (`quantity`). Если передан `user_id`, заказ сохраняется в историю заказов профиля, иначе возвращается сообщение об успешном оформлении заказа. 
         * @summary Создание заказа
         * @param {CatalogCreateOrderPostRequest} catalogCreateOrderPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCreateOrderPost: async (catalogCreateOrderPostRequest: CatalogCreateOrderPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogCreateOrderPostRequest' is not null or undefined
            assertParamExists('catalogCreateOrderPost', 'catalogCreateOrderPostRequest', catalogCreateOrderPostRequest)
            const localVarPath = `/catalog/create-order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(catalogCreateOrderPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает конкретный товар по его ID.
         * @summary Получение конкретного товара по ID
         * @param {number} id ID товара
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogIdInfoGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('catalogIdInfoGet', 'id', id)
            const localVarPath = `/catalog/{id}/info`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает 4 товара из каталога. Если передан параметр is_main, то возвращаются первые 4 товара (отсортированные по возрастанию id), иначе возвращаются 4 случайных товара. is_main нужен для главной страницы только, для остальные случаев не прокидываем этот параметр. 
         * @summary Получение рекомендуемых товаров
         * @param {boolean} [isMain] Если установлен в true, возвращает первые 4 товара, иначе — 4 случайных товара.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogRecommendationsGet: async (isMain?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/catalog/recommendations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isMain !== undefined) {
                localVarQueryParameter['is_main'] = isMain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogApi - functional programming interface
 * @export
 */
export const CatalogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CatalogApiAxiosParamCreator(configuration)
    return {
        /**
         * Возвращает список товаров с возможностью фильтрации по типу и поддержки пагинации.
         * @summary Получение списка товаров
         * @param {string} [type] Фильтр по типу товара (без учета регистра).
         * @param {number} [page] Номер страницы для пагинации.
         * @param {number} [limit] Количество элементов на странице.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async catalogAllListGet(type?: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogAllListGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.catalogAllListGet(type, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogApi.catalogAllListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Принимает заказ в виде массива объектов, где каждый объект содержит идентификатор товара (`product_id`) и его количество (`quantity`). Если передан `user_id`, заказ сохраняется в историю заказов профиля, иначе возвращается сообщение об успешном оформлении заказа. 
         * @summary Создание заказа
         * @param {CatalogCreateOrderPostRequest} catalogCreateOrderPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async catalogCreateOrderPost(catalogCreateOrderPostRequest: CatalogCreateOrderPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogCreateOrderPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.catalogCreateOrderPost(catalogCreateOrderPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogApi.catalogCreateOrderPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает конкретный товар по его ID.
         * @summary Получение конкретного товара по ID
         * @param {number} id ID товара
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async catalogIdInfoGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogAllListGet200ResponseDataInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.catalogIdInfoGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogApi.catalogIdInfoGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает 4 товара из каталога. Если передан параметр is_main, то возвращаются первые 4 товара (отсортированные по возрастанию id), иначе возвращаются 4 случайных товара. is_main нужен для главной страницы только, для остальные случаев не прокидываем этот параметр. 
         * @summary Получение рекомендуемых товаров
         * @param {boolean} [isMain] Если установлен в true, возвращает первые 4 товара, иначе — 4 случайных товара.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async catalogRecommendationsGet(isMain?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogRecommendationsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.catalogRecommendationsGet(isMain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogApi.catalogRecommendationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CatalogApi - factory interface
 * @export
 */
export const CatalogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CatalogApiFp(configuration)
    return {
        /**
         * Возвращает список товаров с возможностью фильтрации по типу и поддержки пагинации.
         * @summary Получение списка товаров
         * @param {CatalogApiCatalogAllListGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogAllListGet(requestParameters: CatalogApiCatalogAllListGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CatalogAllListGet200Response> {
            return localVarFp.catalogAllListGet(requestParameters.type, requestParameters.page, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Принимает заказ в виде массива объектов, где каждый объект содержит идентификатор товара (`product_id`) и его количество (`quantity`). Если передан `user_id`, заказ сохраняется в историю заказов профиля, иначе возвращается сообщение об успешном оформлении заказа. 
         * @summary Создание заказа
         * @param {CatalogApiCatalogCreateOrderPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogCreateOrderPost(requestParameters: CatalogApiCatalogCreateOrderPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<CatalogCreateOrderPost200Response> {
            return localVarFp.catalogCreateOrderPost(requestParameters.catalogCreateOrderPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает конкретный товар по его ID.
         * @summary Получение конкретного товара по ID
         * @param {CatalogApiCatalogIdInfoGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogIdInfoGet(requestParameters: CatalogApiCatalogIdInfoGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<CatalogAllListGet200ResponseDataInner> {
            return localVarFp.catalogIdInfoGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает 4 товара из каталога. Если передан параметр is_main, то возвращаются первые 4 товара (отсортированные по возрастанию id), иначе возвращаются 4 случайных товара. is_main нужен для главной страницы только, для остальные случаев не прокидываем этот параметр. 
         * @summary Получение рекомендуемых товаров
         * @param {CatalogApiCatalogRecommendationsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogRecommendationsGet(requestParameters: CatalogApiCatalogRecommendationsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CatalogRecommendationsGet200Response> {
            return localVarFp.catalogRecommendationsGet(requestParameters.isMain, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for catalogAllListGet operation in CatalogApi.
 * @export
 * @interface CatalogApiCatalogAllListGetRequest
 */
export interface CatalogApiCatalogAllListGetRequest {
    /**
     * Фильтр по типу товара (без учета регистра).
     * @type {string}
     * @memberof CatalogApiCatalogAllListGet
     */
    readonly type?: string

    /**
     * Номер страницы для пагинации.
     * @type {number}
     * @memberof CatalogApiCatalogAllListGet
     */
    readonly page?: number

    /**
     * Количество элементов на странице.
     * @type {number}
     * @memberof CatalogApiCatalogAllListGet
     */
    readonly limit?: number
}

/**
 * Request parameters for catalogCreateOrderPost operation in CatalogApi.
 * @export
 * @interface CatalogApiCatalogCreateOrderPostRequest
 */
export interface CatalogApiCatalogCreateOrderPostRequest {
    /**
     * 
     * @type {CatalogCreateOrderPostRequest}
     * @memberof CatalogApiCatalogCreateOrderPost
     */
    readonly catalogCreateOrderPostRequest: CatalogCreateOrderPostRequest
}

/**
 * Request parameters for catalogIdInfoGet operation in CatalogApi.
 * @export
 * @interface CatalogApiCatalogIdInfoGetRequest
 */
export interface CatalogApiCatalogIdInfoGetRequest {
    /**
     * ID товара
     * @type {number}
     * @memberof CatalogApiCatalogIdInfoGet
     */
    readonly id: number
}

/**
 * Request parameters for catalogRecommendationsGet operation in CatalogApi.
 * @export
 * @interface CatalogApiCatalogRecommendationsGetRequest
 */
export interface CatalogApiCatalogRecommendationsGetRequest {
    /**
     * Если установлен в true, возвращает первые 4 товара, иначе — 4 случайных товара.
     * @type {boolean}
     * @memberof CatalogApiCatalogRecommendationsGet
     */
    readonly isMain?: boolean
}

/**
 * CatalogApi - object-oriented interface
 * @export
 * @class CatalogApi
 * @extends {BaseAPI}
 */
export class CatalogApi extends BaseAPI {
    /**
     * Возвращает список товаров с возможностью фильтрации по типу и поддержки пагинации.
     * @summary Получение списка товаров
     * @param {CatalogApiCatalogAllListGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public catalogAllListGet(requestParameters: CatalogApiCatalogAllListGetRequest = {}, options?: RawAxiosRequestConfig) {
        return CatalogApiFp(this.configuration).catalogAllListGet(requestParameters.type, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Принимает заказ в виде массива объектов, где каждый объект содержит идентификатор товара (`product_id`) и его количество (`quantity`). Если передан `user_id`, заказ сохраняется в историю заказов профиля, иначе возвращается сообщение об успешном оформлении заказа. 
     * @summary Создание заказа
     * @param {CatalogApiCatalogCreateOrderPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public catalogCreateOrderPost(requestParameters: CatalogApiCatalogCreateOrderPostRequest, options?: RawAxiosRequestConfig) {
        return CatalogApiFp(this.configuration).catalogCreateOrderPost(requestParameters.catalogCreateOrderPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает конкретный товар по его ID.
     * @summary Получение конкретного товара по ID
     * @param {CatalogApiCatalogIdInfoGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public catalogIdInfoGet(requestParameters: CatalogApiCatalogIdInfoGetRequest, options?: RawAxiosRequestConfig) {
        return CatalogApiFp(this.configuration).catalogIdInfoGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает 4 товара из каталога. Если передан параметр is_main, то возвращаются первые 4 товара (отсортированные по возрастанию id), иначе возвращаются 4 случайных товара. is_main нужен для главной страницы только, для остальные случаев не прокидываем этот параметр. 
     * @summary Получение рекомендуемых товаров
     * @param {CatalogApiCatalogRecommendationsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public catalogRecommendationsGet(requestParameters: CatalogApiCatalogRecommendationsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return CatalogApiFp(this.configuration).catalogRecommendationsGet(requestParameters.isMain, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Изменяет пароль пользователя. Требуется предоставить старый и новый пароль.
         * @summary Изменение пароля пользователя
         * @param {ProfileChangePasswordPutRequest} profileChangePasswordPutRequest Объект с паролями для смены
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileChangePasswordPut: async (profileChangePasswordPutRequest: ProfileChangePasswordPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileChangePasswordPutRequest' is not null or undefined
            assertParamExists('profileChangePasswordPut', 'profileChangePasswordPutRequest', profileChangePasswordPutRequest)
            const localVarPath = `/profile/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileChangePasswordPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает данные профиля авторизованного пользователя.
         * @summary Получение информации о профиле
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileInfoGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает историю заказов для авторизованного пользователя.
         * @summary Получение истории заказов пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileOrderHistoryGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/order-history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновляет информацию о банковской карте пользователя. Требуется предоставить номер карты, CVV и дату истечения срока действия.
         * @summary Обновление информации о банковской карте
         * @param {ProfileUpdateCardInfoPutRequest} profileUpdateCardInfoPutRequest Объект с информацией о банковской карте для обновления
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileUpdateCardInfoPut: async (profileUpdateCardInfoPutRequest: ProfileUpdateCardInfoPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileUpdateCardInfoPutRequest' is not null or undefined
            assertParamExists('profileUpdateCardInfoPut', 'profileUpdateCardInfoPutRequest', profileUpdateCardInfoPutRequest)
            const localVarPath = `/profile/update-card-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileUpdateCardInfoPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновляет профиль пользователя. Все поля являются обязательными. Если email изменяется, обновляется также и запись в таблице users.
         * @summary Обновление профиля пользователя
         * @param {ProfileUpdateProfilePutRequest} profileUpdateProfilePutRequest Объект с данными для обновления профиля
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileUpdateProfilePut: async (profileUpdateProfilePutRequest: ProfileUpdateProfilePutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileUpdateProfilePutRequest' is not null or undefined
            assertParamExists('profileUpdateProfilePut', 'profileUpdateProfilePutRequest', profileUpdateProfilePutRequest)
            const localVarPath = `/profile/update-profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileUpdateProfilePutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список всех пользователей с их email, ролью и ФИО (если есть профиль). Поддерживает пагинацию, фильтрацию по роли и поиск по email или user_id.
         * @summary Получение списка пользователей
         * @param {string} [search] Поиск по email или user_id
         * @param {ProfileUsersGetRoleEnum} [role] Фильтрация по роли
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Количество пользователей на странице
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileUsersGet: async (search?: string, role?: ProfileUsersGetRoleEnum, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * Изменяет пароль пользователя. Требуется предоставить старый и новый пароль.
         * @summary Изменение пароля пользователя
         * @param {ProfileChangePasswordPutRequest} profileChangePasswordPutRequest Объект с паролями для смены
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profileChangePasswordPut(profileChangePasswordPutRequest: ProfileChangePasswordPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileChangePasswordPut200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profileChangePasswordPut(profileChangePasswordPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.profileChangePasswordPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает данные профиля авторизованного пользователя.
         * @summary Получение информации о профиле
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profileInfoGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileInfoGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profileInfoGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.profileInfoGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает историю заказов для авторизованного пользователя.
         * @summary Получение истории заказов пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profileOrderHistoryGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileOrderHistoryGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profileOrderHistoryGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.profileOrderHistoryGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Обновляет информацию о банковской карте пользователя. Требуется предоставить номер карты, CVV и дату истечения срока действия.
         * @summary Обновление информации о банковской карте
         * @param {ProfileUpdateCardInfoPutRequest} profileUpdateCardInfoPutRequest Объект с информацией о банковской карте для обновления
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profileUpdateCardInfoPut(profileUpdateCardInfoPutRequest: ProfileUpdateCardInfoPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileUpdateCardInfoPut200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profileUpdateCardInfoPut(profileUpdateCardInfoPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.profileUpdateCardInfoPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Обновляет профиль пользователя. Все поля являются обязательными. Если email изменяется, обновляется также и запись в таблице users.
         * @summary Обновление профиля пользователя
         * @param {ProfileUpdateProfilePutRequest} profileUpdateProfilePutRequest Объект с данными для обновления профиля
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profileUpdateProfilePut(profileUpdateProfilePutRequest: ProfileUpdateProfilePutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileUpdateProfilePut200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profileUpdateProfilePut(profileUpdateProfilePutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.profileUpdateProfilePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает список всех пользователей с их email, ролью и ФИО (если есть профиль). Поддерживает пагинацию, фильтрацию по роли и поиск по email или user_id.
         * @summary Получение списка пользователей
         * @param {string} [search] Поиск по email или user_id
         * @param {ProfileUsersGetRoleEnum} [role] Фильтрация по роли
         * @param {number} [page] Номер страницы
         * @param {number} [limit] Количество пользователей на странице
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profileUsersGet(search?: string, role?: ProfileUsersGetRoleEnum, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileUsersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profileUsersGet(search, role, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.profileUsersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileApiFp(configuration)
    return {
        /**
         * Изменяет пароль пользователя. Требуется предоставить старый и новый пароль.
         * @summary Изменение пароля пользователя
         * @param {ProfileApiProfileChangePasswordPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileChangePasswordPut(requestParameters: ProfileApiProfileChangePasswordPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProfileChangePasswordPut200Response> {
            return localVarFp.profileChangePasswordPut(requestParameters.profileChangePasswordPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает данные профиля авторизованного пользователя.
         * @summary Получение информации о профиле
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileInfoGet(options?: RawAxiosRequestConfig): AxiosPromise<ProfileInfoGet200Response> {
            return localVarFp.profileInfoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает историю заказов для авторизованного пользователя.
         * @summary Получение истории заказов пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileOrderHistoryGet(options?: RawAxiosRequestConfig): AxiosPromise<ProfileOrderHistoryGet200Response> {
            return localVarFp.profileOrderHistoryGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Обновляет информацию о банковской карте пользователя. Требуется предоставить номер карты, CVV и дату истечения срока действия.
         * @summary Обновление информации о банковской карте
         * @param {ProfileApiProfileUpdateCardInfoPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileUpdateCardInfoPut(requestParameters: ProfileApiProfileUpdateCardInfoPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProfileUpdateCardInfoPut200Response> {
            return localVarFp.profileUpdateCardInfoPut(requestParameters.profileUpdateCardInfoPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновляет профиль пользователя. Все поля являются обязательными. Если email изменяется, обновляется также и запись в таблице users.
         * @summary Обновление профиля пользователя
         * @param {ProfileApiProfileUpdateProfilePutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileUpdateProfilePut(requestParameters: ProfileApiProfileUpdateProfilePutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProfileUpdateProfilePut200Response> {
            return localVarFp.profileUpdateProfilePut(requestParameters.profileUpdateProfilePutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает список всех пользователей с их email, ролью и ФИО (если есть профиль). Поддерживает пагинацию, фильтрацию по роли и поиск по email или user_id.
         * @summary Получение списка пользователей
         * @param {ProfileApiProfileUsersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileUsersGet(requestParameters: ProfileApiProfileUsersGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ProfileUsersGet200Response> {
            return localVarFp.profileUsersGet(requestParameters.search, requestParameters.role, requestParameters.page, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for profileChangePasswordPut operation in ProfileApi.
 * @export
 * @interface ProfileApiProfileChangePasswordPutRequest
 */
export interface ProfileApiProfileChangePasswordPutRequest {
    /**
     * Объект с паролями для смены
     * @type {ProfileChangePasswordPutRequest}
     * @memberof ProfileApiProfileChangePasswordPut
     */
    readonly profileChangePasswordPutRequest: ProfileChangePasswordPutRequest
}

/**
 * Request parameters for profileUpdateCardInfoPut operation in ProfileApi.
 * @export
 * @interface ProfileApiProfileUpdateCardInfoPutRequest
 */
export interface ProfileApiProfileUpdateCardInfoPutRequest {
    /**
     * Объект с информацией о банковской карте для обновления
     * @type {ProfileUpdateCardInfoPutRequest}
     * @memberof ProfileApiProfileUpdateCardInfoPut
     */
    readonly profileUpdateCardInfoPutRequest: ProfileUpdateCardInfoPutRequest
}

/**
 * Request parameters for profileUpdateProfilePut operation in ProfileApi.
 * @export
 * @interface ProfileApiProfileUpdateProfilePutRequest
 */
export interface ProfileApiProfileUpdateProfilePutRequest {
    /**
     * Объект с данными для обновления профиля
     * @type {ProfileUpdateProfilePutRequest}
     * @memberof ProfileApiProfileUpdateProfilePut
     */
    readonly profileUpdateProfilePutRequest: ProfileUpdateProfilePutRequest
}

/**
 * Request parameters for profileUsersGet operation in ProfileApi.
 * @export
 * @interface ProfileApiProfileUsersGetRequest
 */
export interface ProfileApiProfileUsersGetRequest {
    /**
     * Поиск по email или user_id
     * @type {string}
     * @memberof ProfileApiProfileUsersGet
     */
    readonly search?: string

    /**
     * Фильтрация по роли
     * @type {'whosale' | 'regular'}
     * @memberof ProfileApiProfileUsersGet
     */
    readonly role?: ProfileUsersGetRoleEnum

    /**
     * Номер страницы
     * @type {number}
     * @memberof ProfileApiProfileUsersGet
     */
    readonly page?: number

    /**
     * Количество пользователей на странице
     * @type {number}
     * @memberof ProfileApiProfileUsersGet
     */
    readonly limit?: number
}

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
    /**
     * Изменяет пароль пользователя. Требуется предоставить старый и новый пароль.
     * @summary Изменение пароля пользователя
     * @param {ProfileApiProfileChangePasswordPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public profileChangePasswordPut(requestParameters: ProfileApiProfileChangePasswordPutRequest, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).profileChangePasswordPut(requestParameters.profileChangePasswordPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает данные профиля авторизованного пользователя.
     * @summary Получение информации о профиле
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public profileInfoGet(options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).profileInfoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает историю заказов для авторизованного пользователя.
     * @summary Получение истории заказов пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public profileOrderHistoryGet(options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).profileOrderHistoryGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновляет информацию о банковской карте пользователя. Требуется предоставить номер карты, CVV и дату истечения срока действия.
     * @summary Обновление информации о банковской карте
     * @param {ProfileApiProfileUpdateCardInfoPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public profileUpdateCardInfoPut(requestParameters: ProfileApiProfileUpdateCardInfoPutRequest, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).profileUpdateCardInfoPut(requestParameters.profileUpdateCardInfoPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновляет профиль пользователя. Все поля являются обязательными. Если email изменяется, обновляется также и запись в таблице users.
     * @summary Обновление профиля пользователя
     * @param {ProfileApiProfileUpdateProfilePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public profileUpdateProfilePut(requestParameters: ProfileApiProfileUpdateProfilePutRequest, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).profileUpdateProfilePut(requestParameters.profileUpdateProfilePutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает список всех пользователей с их email, ролью и ФИО (если есть профиль). Поддерживает пагинацию, фильтрацию по роли и поиск по email или user_id.
     * @summary Получение списка пользователей
     * @param {ProfileApiProfileUsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public profileUsersGet(requestParameters: ProfileApiProfileUsersGetRequest = {}, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).profileUsersGet(requestParameters.search, requestParameters.role, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ProfileUsersGetRoleEnum = {
    Whosale: 'whosale',
    Regular: 'regular'
} as const;
export type ProfileUsersGetRoleEnum = typeof ProfileUsersGetRoleEnum[keyof typeof ProfileUsersGetRoleEnum];


